%*******************************************************************************
% Example chapter file for books, Copyright A K Peters, Ltd.
%*******************************************************************************
\chapter{Exploring Mobile vs. Desktop OpenGL Performance}{Jon McCaffrey}
 \label{Exploring-Mobile-vs-Desktop-OpenGL-Performance}

\section{Introduction}

The stunning rise of mobile platforms has created a large nascent market for new 3D applications and games where, excitingly, OpenGL ES is the \textit{lingua franca} for graphics. However, mobile platforms and GPUs have performance profiles and characteristics that may be unfamiliar and surprising to desktop developers.  Developers and applications hoping to make the transition

% TODO Finish introduction

\section{Constraint Inspires Creativity}\label{YourName:Constraints-Inspire-Creativity}

\subsection{Differences in Scale}\label{Jon-McCaffrey:Architectural-Differences}
Modern mobile devices are capable and remarkable devices.  However, they face much greater limitations than desktop systems in terms of cost, die size, power consumption, and heat dissipation.

TODO better scale context

\subsection{Differnces in Rendering Architecture}\label{Jon-McCaffrey:differences-in-rendering-architecture}

Mobile and desktop GPUs don't differ only in scale.  Many mobile GPUs such as the PowerVR SGX543MP2 used in the Apple iPhone 4S/iPad 2 and the Mali-400 used in the Samsung Galaxy S2 use a rendering architecture known as \textit{Tile-Based Deferred Rendering (TBDR)}.  In contrast, familiar desktop GPUs from Nvidia and ATI and mobile GPUs like the GeForce ULV GPU use in the Samsung Galaxy Tab 10.1 use \textit{Immediate Mode Rendering}.

TODO link for TBDR vs IMR http://www.anandtech.com/Show/Index/4686?cPage=13&all=False&sort=0&page=15&slug=samsung-galaxy-s-2-international-review-the-best-redefined

In IMRs, vertices are transformed once and each primitive is rasterized essentially in order.  If a fragment passes depth-testing (assuming the platform has early-z), it will be shaded and will write to the framebuffer.  However, a later fragment may over-write this pixel, nullifying the earlier work done and writing the framebuffer again.  This issue is known as overdraw.  Even without overdraw, the depth buffer still must be read in order to reject fragments.

TBDRs instead divide the scene into tiles.  All draw commands are buffered, or deferred.  At the end of the frame, for each tile, all geometry for the scene is re-rendered and rasterized with that tile scissored out.  Before any fragments are shaded, all \textit{Hidden Surface Removal (HSR)} and depth-testing is performed in a fast framebuffer cache.  Assuming opaque geometry, each pixel is then shaded and writted to the framebuffer exactly once.

These architectures have different strengths and weaknesses we will consider, but it's important to note that the mobile GPU landscape is not homogenous.  Optimizations may benefit the different architectures very differently.

\subsection{Differences in Memory Architecture}\label{Jon-McCaffrey:differences-in-memory-architecture}

On desktop systems, high-end GPUs are discrete devices which communicate with the rest of the system via a peripheral bus like \textit{PCIe}.  For good performance, this means that GPUs must include their own dedicated memory.  While this increases cost, it is an optimization opportunity since this memory can be optimized for graphics workloads.

For example, the Nvidia \textit{Fermi} architecture uses GDDR5 memory that is heavily partitioned (TODO link http://www.techspot.com/review/263-nvidia-geforce-gtx-480/page2.html) to allow for very wide memory interface.  There is also no competition for this bandwidth, since except for uploads from the rest of the system and scan-out for output devices, the GPU is the only user of this memory.

In mobile devices, on the other hand, the GPU is usually integrated into the same \textit{System-on-a-Chip (SoC)} as the CPU and other components, and to save cost, power, size, and complexity, shares the same RAM and memory interface.  This is known as an \textit{Unified Memory Architecture (UMA)}.  A common memory type might be the low-power LPDDR2, which has a 32-bit wide interface. (http://www.anandtech.com/show/4144/lg-optimus-2x-nvidia-tegra-2-review-the-first-dual-core-smartphone/5).  Not only is this memory general-purpose, the GPU now shares bandwidth with other parts of the system like the CPU, network, camera, multimedia, and display.   

There are some advantages to an unified memory architecture.  With discrete GPU's the peripheral bus could become a bottleneck for transfers, especially with non-PCIe buses with asymmetric speeds (TODO link phttp://developer.download.nvidia.com/assets/gamedev/docs/Fast_Texture_Transfers.pdf?display=style-table).  With a UMA, OpenGL client and server data are in fact stored in the same RAM.  Even if it is not possible to directly access server data with \texttt{glMapBufferOES}, there are less performance cliffs lurking in transfers between OpenGL client and server data.

One limitation is that OpenGL ES does not yet have an extension for \textit{Pixel Buffer Objects (PBO)}, meaning that pixel data must be transferred synchronously.  This makes the comparatively cheap bandwidth between client and server data less useful.

\section{Mobile Performance Pressures}\label{Jon-McCaffrey:differences-in-memory-architecture}
\subsection{Relative Display Sizes}\label{Jon-McCaffrey:differences-in-memory-architecture}



\section{Conclusion}

TODO conclude


\bibliographystyle{akpbib}
\bibliography{YourBib}











